#! /usr/bin/perl -w

# conf2struct: generate libconf parsers that read to structs
# Copyright (C) 2018-2019  Yves Rutschle
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice,
#    this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

use strict;

use Conf::Libconfig;
use Getopt::Long;

use Data::Dumper;

my $date = scalar localtime;
my $banner = <<EOF;
/* Generated by conf2struct (https://www.rutschle.net/tech/conf2struct/README)
 * on $date. */
EOF


my $conf = Conf::Libconfig->new;
my $filename = shift @ARGV;
die "Usage:\n\tconf2struct <file.cfg>\n" unless defined $filename;
$conf->read_file($filename) or die "$filename: $!\n";
my $hr = $conf->fetch_hashref("/");

my $header = $hr->{header};
my $parser = $hr->{parser};


################################################################################
# Turns a libconfig type to a C type or undef if unknown type
sub scalar_type {
    my ($in) = @_;
    my $out = {
        'bool' => 'int',
        'int' => 'int',
        'int64' => 'long long',
        'float' => 'double',
        'string' => 'char*',
    }->{$in};
    return $out;
}

################################################################################
# Turns a libconfig type to the corresponding libconfig function to parse it
sub scalar_type_lookup {
    my ($in) = @_;
    {
        'bool'          => 'config_setting_lookup_bool',
        'int'           => 'config_setting_lookup_int',
        'int64'         => 'config_setting_lookup_int64',
        'float'         => 'config_setting_lookup_float',
        'string'        => 'config_setting_lookup_string',
    }->{$in};
}

################################################################################
sub scalar_type_get {
    my ($in) = @_;
    {
        'bool'       => 'config_setting_get_bool',
        'int'           => 'config_setting_get_int',
        'int64'         => 'config_setting_get_int64',
        'float'         => 'config_setting_get_float',
        'string'        => 'config_setting_get_string',
    }->{$in};
}

################################################################################
# Returns the printf format to print the libconfig type
sub scalar_type_print {
    my ($in) = @_;
    {
        'bool' => '%d',
        'int' => '%d',
        'int64' => "%ld",
        'float' => "%f",
        'string' => '%s',
    }->{$in};
}

################################################################################
# Turn libconfig setting names to C struct names
sub cfgname2c {
    my ($name) = @_;
    $name =~ s/[-.]/_/g;
    return $name;
}

################################################################################
# C code included in output

my %snippets = (
header => <<'EOF',

/* This gets included in the output .c file */


/* config_type and lookup_fns are related, keep them together */
typedef enum {
    CFG_BOOL,
    CFG_INT,
    CFG_INT64,
    CFG_FLOAT,
    CFG_STRING,
    CFG_GROUP,
    CFG_ARRAY,
    CFG_LIST,
} config_type;

typedef int (*lookup_fn)(const config_setting_t*, const char*, void*);
lookup_fn lookup_fns[] = {
    (lookup_fn)config_setting_lookup_bool,
    (lookup_fn)config_setting_lookup_int,
    (lookup_fn)config_setting_lookup_int64,
    (lookup_fn)config_setting_lookup_float,
    (lookup_fn)config_setting_lookup_string,
    #if 0
    NULL,  /* CFG_GROUP */
    NULL,  /* CFG_ARRAY */
    NULL,  /* CFG_LIST */
    #endif
};

typedef union {
    int def_bool;
    int def_int;
    long long def_int64;
    double def_float;
    char* def_string;
} any_val;

typedef struct {
    any_val val;
} s_any_val;

/* Copy an any_val to arbitrary memory location */
static void any_valcpy(config_type type, void* target, any_val val)
{
    switch(type) {
    case CFG_BOOL:
        *(int*)target = val.def_bool;
        break;

    case CFG_INT:
        *(int*)target = val.def_int;
        break;

    case CFG_INT64:
        *(long long*)target = val.def_int64;
        break;

    case CFG_FLOAT:
        *(double*)target = val.def_float;
        break;

    case CFG_STRING:
        *(char**)target = val.def_string;
        break;

    default:
        fprintf(stderr, "Unknown type specification %d\n", type);
        exit(1);
    }
}


/* Copy the value of a setting to an arbitrary memory that
* must be large enough */
static void settingcpy(config_type type, void* target, const config_setting_t* setting)
{
    any_val val;
    char* str;

    switch(type) {
    case CFG_BOOL:
        val.def_bool = config_setting_get_bool(setting);
        *(int*)target = val.def_bool;
        break;

    case CFG_INT:
        val.def_int = config_setting_get_int(setting);
        *(int*)target = val.def_int;
        break;

    case CFG_INT64:
        val.def_int64 = config_setting_get_int64(setting);
        *(long long*)target = val.def_int64;
        break;

    case CFG_FLOAT:
        val.def_float = config_setting_get_float(setting);
        *(double*)target = val.def_int64;
        break;

    case CFG_STRING:
        asprintf(&str, "%s", config_setting_get_string(setting));
        val.def_string = str;
        *(char**)target = val.def_string;
        break;

    default:
        fprintf(stderr, "Unknown type specification %d\n", type);
        exit(1);
    }
}

/* Copy the value of a command line arg to arbitrary memory
* that must be large enough for the type */
static void clcpy(config_type type, void* target, const void* cl_arg)
{
    any_val val;
    char* str;

    switch(type) {
    case CFG_BOOL:
        val.def_bool = (*(struct arg_lit**)cl_arg)->count;
        *(int*)target = val.def_bool;
        break;

    case CFG_INT:
        val.def_int = (*(struct arg_int**)cl_arg)->ival[0];
        *(int*)target = val.def_int;
        break;

    case CFG_INT64:
        val.def_int64 = (*(struct arg_int**)cl_arg)->ival[0];
        *(long long*)target = val.def_int64;
        break;

    case CFG_FLOAT:
        val.def_float = (*(struct arg_dbl**)cl_arg)->dval[0];
        *(double*)target = val.def_float;
        break;

    case CFG_STRING:
        asprintf(&str, "%s", (*(struct arg_str**)cl_arg)->sval[0]);
        val.def_string = str;
        *(char**)target = val.def_string;
        break;

    default:
        fprintf(stderr, "Unknown type specification %d\n", type);
        exit(1);
    }
}

/* Copy the value of a string argument to arbitary memory
* location that must be large enough, converting on the way
* (i.e. CFG_INT gets atoi() and so on) */
static void stringcpy(config_type type, void* target, char* from)
{
    any_val val;
    char* str;
    
    switch(type) {
    case CFG_BOOL:
        val.def_bool = (*from != '0');
        *(int*)target = val.def_bool;
        break;

    case CFG_INT:
        val.def_int = strtol(from, NULL, 10);
        *(int*)target = val.def_int;
        break;

    case CFG_INT64:
        val.def_int64 = strtoll(from, NULL, 10);
        *(long long*)target = val.def_int64;
        break;

    case CFG_FLOAT:
        val.def_float = strtod(from, NULL);
        *(double*)target = val.def_float;
        break;

    case CFG_STRING:
        val.def_string = from;
        *(char**)target = val.def_string;
        break;

    default:
        fprintf(stderr, "Unknown type specification %d\n", type);
        exit(1);
    }
}


struct config_entry {
    const char* name;
    int type;
    struct config_entry* sub_group; /* Table for compound types (list and group) */
    void* arg_cl; /* command-line argument for this setting */
    void* base_addr; /* Base of the structure (filled at runtime) */
    size_t offset;  /* Offset of setting in the structure */
    size_t offset_len; /* Offset of *_len field, for arrays and lists */
    size_t offset_present; /* offset of *_is_present field, for optional settings */
    size_t size;   /* Size of element, or size of group for groups and lists */
    int array_type; /* type of array elements, when type == CFG_ARRAY */
    int mandatory;
    int optional;
    any_val default_val;
};

/* Element to describe the target of a compound element
* element: which config entry is being changed
* match: if >0, index in pmatch to set
*        if 0, don't match but init with value
* value: constant if not matching */
struct compound_cl_target {
    struct config_entry* element;
    int match;
    any_val value;
};

/* Element to describe one compound command line argument
 * An argument is string that gets matched against a regex,
 * then match-groups get evaluated to each targets[].
 * For lists, base_entry points to the config_setting so we
 * can append to it */
struct compound_cl_arg {
    const char* regex;
    struct arg_str** arg_cl; /* arg_str entry for this compound option */
    struct config_entry* base_entry;
    struct compound_cl_target* targets;
    struct config_entry* override;
};


EOF


c_read_block => <<'EOF',

/* Enable debug to follow the parsing of tables */
#if 0
#define TRACE_READ(x) printf x
#define TRACE_READ_PRINT_SETTING 1
#else
#define TRACE_READ(x)
#define TRACE_READ_PRINT_SETTING 0
#endif

/* Enable debug to follow the parsing of compound options */
#if 0
#define TRACE_CMPD(x) printf x
#define TRACE_CMPD_PRINT_SETTING 1
#else
#define TRACE_CMPD(x)
#define TRACE_CMPD_PRINT_SETTING 0
#endif

static void print_setting(config_type type, void* val)
{
    if (TRACE_READ_PRINT_SETTING || TRACE_CMPD_PRINT_SETTING) {
        switch(type) {
        case CFG_BOOL:
        case CFG_INT:
            printf("%d", *(int*)val);
            break;
        case CFG_INT64:
            printf("%lld", *(long*)val);
            break;
        case CFG_FLOAT:
            printf("%f", *(double*)val);
            break;
        case CFG_STRING:
            printf("`%s'", *(char**)val);
            break;
        }
    }
}

/* Reads from libconfig object `cfg` into struct `setting` according to format `e` */
static int read_block(config_setting_t* cfg, void* setting, struct config_entry* e, char** errmsg)
{
    lookup_fn lookup_fn;
    s_any_val val;
    config_setting_t* s;
    void* block;
    size_t len;
    int res; char out[128] = {0};

    for (; e->name; e++) {
        TRACE_READ(("reading %s%s%s: ", e->optional ? "optional " : "", e->mandatory ? "mandatory " : "",  e->name));
        e->base_addr = setting;
        memset((char*)setting + e->offset, e->size, 0);
        if (s = config_setting_lookup(cfg, e->name)) {
            switch (e->type) {
            case CFG_LIST:
            case CFG_ARRAY:
                len = config_setting_length(s);
                block = malloc(e->size * len);
                for (int i = 0; i < len; i++) {
                    config_setting_t* elem = config_setting_get_elem(s, i);
                    if (e->type == CFG_LIST) {
                        if (!read_block(elem, (char*)block + e->size * i, e->sub_group, errmsg))
                            return 0;
                    } else { /* CFG_ARRAY */
                        settingcpy(e->array_type, (char*)block + e->size * i, elem);
                        TRACE_READ(("[%d] = ", i));
                        print_setting(e->array_type, (char*)block + e->size *i); TRACE_READ(("\n"));
                    }
                }
                *(size_t*)(((char*)setting) + e->offset_len) = len;
                *(void**)(((char*)setting) + e->offset) = block;
                break;

            case CFG_GROUP:
                block = malloc(e->size);
                if (!read_block(s, block, e->sub_group , errmsg)) return 0;
                *(void**)(((char*)setting) + e->offset) = block;
                break;


            default:
                /* First, lookup in config file */
                lookup_fn = lookup_fns[e->type];
                if (lookup_fn(cfg, e->name, ((char*)setting) + e->offset) == CONFIG_FALSE) {
                    asprintf(errmsg, "Parsing of option \"%s\" failed", e->name);
                    return 0;
                }
                print_setting(e->type, (((char*)setting) + e->offset)); TRACE_READ(("\n"));
            }
            if (e->optional) { /* set field _is_present = 1 */
                TRACE_READ(("set optional at offset: %X sizeof(int)=%d\n",  e->offset,sizeof(int)));
                *(int*)((char*)setting + e->offset_present) = 1;
            }
        } else {
            TRACE_READ(("not found "));
            if (e->mandatory && !e->optional) {
                asprintf(errmsg, "Mandatory option \"%s\" not found", e->name);
                return 0;
            }
            TRACE_READ((", setting to ")); print_setting(e->type, &e->default_val); TRACE_READ(("\n"));
            memcpy(((char*)setting) + e->offset, &e->default_val, e->size);
        }
        /* Then, override from command line */ 
        if (e->arg_cl) {
            /*(all arg_* structs start the same so we can cast to any arg_ type we want) */
            if ((*(struct arg_int**)e->arg_cl)->count) {
                TRACE_READ(("command line override to "));
                clcpy(e->type, ((char*)setting) + e->offset, e->arg_cl);
                print_setting(e->type, (((char*)setting) + e->offset)); TRACE_READ(("\n"));
            }
        }
        TRACE_READ(("done %s\n", e->name));
    }
    return 1;
}


/* Processes a list of targets within one element, setting
* the values in the target setting 
* arg: CL arg containing the target fields
* clval: command line parameter
* pmatch: regex match array into clval
*/
static int set_target_fields(struct compound_cl_arg* arg, const char* clval, regmatch_t* pmatch)
{
    int pmatch_cnt = 1;
    struct compound_cl_target* target;

    for (target = arg->targets; target->element; target++) {
        struct config_entry* element = target->element;
        if (target->match) {
            TRACE_CMPD(("    match %d rm_so %d rm_eo %d type %d\n", 
                        pmatch_cnt, pmatch[pmatch_cnt].rm_so, pmatch[pmatch_cnt].rm_eo, element->type ));
            if (pmatch[pmatch_cnt].rm_so == -1) {
                /* This should not happen as regexec() did
                * match before, unless there is a
                * discrepency between the regex and the
                * number of backreferences */
                return 0;
            }
            int len = pmatch[pmatch_cnt].rm_eo - pmatch[pmatch_cnt].rm_so;
            char* str = calloc(len+1, 1);
            memcpy(str, clval + pmatch[pmatch_cnt].rm_so, len);
            stringcpy(element->type, (char*)element->base_addr + element->offset, str);
            TRACE_CMPD(("setting %X+%d to : ", element->base_addr, element->offset));
            print_setting(element->type , (char*)element->base_addr + element->offset);
            TRACE_CMPD(("\n"));

            /* str is temporary buffer for type conversion, except for strings which we
            * need to keep around so don't free them */
            if (element->type != CFG_STRING) 
                free(str);
            pmatch_cnt++;
        } else { /* don't use matching, set constant */
            any_valcpy(element->type, (char*)element->base_addr + element->offset,
                        target->value);
        }
    }

}

int add_arg_to_list(struct compound_cl_arg* arg, regmatch_t* pmatch)
{
    struct config_entry* desc = arg->base_entry;
    void* list_base = desc->base_addr + desc->offset;
    size_t list_len = *(size_t*)(desc->base_addr + desc->offset_len);
    size_t elem_size = desc->size;
    int i;

    printf("arg_to_list base %X len %d size %d\n", list_base, list_len, elem_size);
    for (i = 0; i < list_len; i++) {
    }

    /* override not found or no override, append element */
    list_len++;
    list_base = realloc(list_base, list_len * elem_size);
    *(size_t*)(desc->base_addr + desc->offset_len) = list_len;
/*    *(void*)(desc->base_addr + desc->offset) = list_base;
*    

    if (!set_target_fields(arg, arg->arg_cl, pmatch)) {
        return 0;
    }
*/

}

/* TODO: pass pmatch size as parameter or something */
#define MAX_MATCH 10

/* Regex fiddling: uses info in arg to fill pmatch */
int regcompmatch(regmatch_t* pmatch, struct compound_cl_arg* arg, char** errmsg)
{
    struct arg_str* arg_cl = *arg->arg_cl;
    regex_t preg;
    int res = regcomp(&preg, arg->regex, REG_EXTENDED);
    if (res) {
        int errlen = regerror(res, &preg, NULL, 0);
        *errmsg = malloc(errlen);
        regerror(res, &preg, *errmsg, errlen);
        return 0;
    }
    res = regexec(&preg, arg_cl->sval[0], MAX_MATCH, &pmatch[0], 0);
    if (res) {
        asprintf(errmsg, "--%s %s: Illegal argument", 
        arg_cl->hdr.longopts, 
        arg->regex); 
        return 0;
    }
    return 1;
}

/* Read compound options described in `arg`, from `cfg`, to `setting` */
static int read_compounds(config_setting_t* cfg, void* setting, struct compound_cl_arg* arg, char** errmsg)
{
    int res, pmatch_cnt;
    struct arg_str* arg_cl;
    regmatch_t pmatch[MAX_MATCH];
    struct compound_cl_target* target;

    for (; arg->regex; arg++) {
        arg_cl = *arg->arg_cl;
        TRACE_CMPD(("Compound %s occurs %d : ", arg_cl->hdr.longopts, arg_cl->count));
        if (arg_cl->count) {
            if (!regcompmatch(&pmatch[0], arg, errmsg))
                return 0;
            TRACE_CMPD(("`%s' matched\n", arg_cl->sval[0]));

            /* In a list, find the end or the element to override */
            if (arg->base_entry->type == CFG_LIST) {
                if (!add_arg_to_list(arg, pmatch)) {
                    return 0;
                }
            }

            /* Semantics for CFG_ARRAY TBD */

            if (!set_target_fields(arg, arg_cl->sval[0], pmatch))
                return 0;

        }
        TRACE_CMPD(("done %s\n", arg_cl->hdr.longopts));
    }
}

/* read config file `filename` into `c` */
static int c2s_parse_file(const char* filename, config_t* c, char**errmsg)
{
    /* Read config file */
    config_init(c);
    if (config_read_file(c, filename) == CONFIG_FALSE) {
        if (config_error_line(c) != 0) {
           asprintf(errmsg, "%s:%d:%s", 
                    filename,
                    config_error_line(c),
                    config_error_text(c));
           return 0;
        }
        asprintf(errmsg, "%s:%s", filename, config_error_text(c));
        return 0;
    }
    return 1;
}

int ##name_cl_parse(int argc, char* argv[], struct eg_item* cfg)
{
    int nerrors, res;
    config_t c;
    char* errmsg;
    config_setting_t* s;
    void* argtable[] = {
        ##r_init
    };

    /* Parse command line */
    nerrors = arg_parse(argc, argv, argtable);
    if (nerrors) {
        arg_print_errors(stdout, ##name_end, "##name"); 
        arg_print_syntax(stdout, argtable, "\\n");
        arg_print_glossary(stdout, argtable, "  %-25s\t%s\\n");
        return 0;
    }


    if (eg_conffile->count) {
        if (!c2s_parse_file(eg_conffile->filename[0], &c, &errmsg)) {
            fprintf(stderr, "%s\n", errmsg);
            exit(1);
        }
    }

    s = config_lookup(&c, "/");

    res = read_block(s, cfg, table_eg, &errmsg);
    if (!res) {
        fprintf(stderr, "%s\n", errmsg);
        return res;
    }

    res = read_compounds(s, cfg, compound_cl_args, &errmsg);
    if (!res) {
        fprintf(stderr, "%s\n", errmsg);
        return res;
    }

    return res;
}

EOF
);


# / C code
################################################################################

################################################################################
# HEADER GENERATION
################################################################################
# Taking a 'setting' (hash with name and @items), returns a
# couple ($structs, $decls) with $structs a string of
# structs needed inside this setting, and $decls the scalar
# definitions for the setting
sub make_decl_list {
    my ($prefix, $setting) = @_;

    my ($structs, $decls) = ("", "");
    foreach my $setting (@{$setting->{items}}) {
        my $name = cfgname2c $setting->{name};
        if ($setting->{type} eq 'list') {
            my $sname = "${prefix}_${name}_item";
            $structs .= make_struct_header("${prefix}_${name}", $setting);
            $decls = "$decls\tsize_t\t${name}_len;\n\tstruct $sname* ${name};\n";
        } elsif ($setting->{type} eq 'group') {
            my $sname = "${prefix}_${name}_item";
            $structs .= make_struct_header("${prefix}_${name}", $setting);
            $decls = "$decls\tstruct $sname* ${name};\n";
        } elsif ($setting->{type} eq 'array') {
            my $type = scalar_type($setting->{element_type});
            $decls= "$decls\tsize_t\t${name}_len;\n\t$type* ${name};\n";
        } elsif ($setting->{type} eq 'runtime') {
            $decls .= "\t$setting->{c_type}\t${name};\n";
        } else {
            my $c_type = scalar_type $setting->{type};
            #if ($setting->{optional} and $setting->{type} eq 'string') {
            if ($setting->{optional}) {
                $decls.= "\tint\t${name}_is_present;\n";
            }
            if ($setting->{var} and $setting->{type} eq 'string') {
                $c_type = "char*";
            }
            $decls.= "\t$c_type\t${name};\n";
        }
    }
    return ($structs, $decls);
}

################################################################################
sub make_struct_header {
    my ($prefix, $setting) = @_;

    my ($s, $l) = make_decl_list($prefix, $setting);
    my $out = "$s\nstruct ${prefix}_item {\n$l};\n";
    return $out;
}

################################################################################
sub make_root_header {
    my ($root) = @_;
    my $setting = $root->{config};
    my $name = cfgname2c $setting->{name};
    my $NAME = uc $name;
    my $out = <<EOF;
$banner 
#ifndef C2S_${NAME}_H
#define C2S_${NAME}_H
#include <libconfig.h>


EOF

foreach my $h (@{$root->{includes}}) {
    $h = "\"$h\"" unless $h =~ /\<.*\>/;
    $out .= "#include $h\n";
}

    $out .= make_struct_header($name, $setting);

    $out .= <<EOF;

int ${name}_parse_file(
        const char* filename,
        struct ${name}_item* $name, 
        const char** errmsg);

void ${name}_fprint(
    FILE* out,
    struct ${name}_item *${name},
    int depth);

int ${name}_cl_parse(
    int argc,
    char* argv[],
    struct ${name}_item *${name});

#endif
EOF

    return $out;
}

################################################################################
# Returns the default for a setting, taking in account type
# and optionality
sub default_value {
    my ($s) = @_;

    return undef unless defined $s->{default};

    if ($s->{type} eq "string") {
        if ($s->{optional}) {
            return "NULL";
        } else {
            return "\"$s->{default}\"";
        }
    } else {
        return $s->{default};
    }
}

################################################################################
# Constructor generation
# (builds struct initialised with defaults)
################################################################################
sub make_init {
    my ($prefix, $in) = @_;

    my $out = <<EOF;
static void ${prefix}_init(struct ${prefix}_item* cfg) {
        memset(cfg, 0, sizeof(*cfg));
EOF

    foreach my $setting (@{$in->{items}}) {
        next if $setting->{type} =~ /runtime/;

        my $name = cfgname2c $setting->{name};
        my $pname = "${prefix}_$name";

        if ($setting->{type} =~ /list|group/) {
            $out = make_init($pname, $setting) . $out;
        } elsif ($setting->{type} =~ /array/) {
            # no defaults for arrays yet
        } else {
            my $default = default_value $setting;
            $out .= "\tcfg->$name = $default;\n" if defined $default;
        }
    }
    $out .= "}\n\n";
}


################################################################################
# PARSER GENERATION
################################################################################
sub make_table {
    my ($name, $top_setting) = @_;
    my @settings = @{$top_setting->{items}};

    my $out = <<EOF;

static struct config_entry table_${name}[] = {

EOF

    foreach my $setting (@settings) {
        next if $setting->{type} eq 'runtime';

        my $sname = cfgname2c $setting->{name};
        my $hname = "${name}_${sname}";
        my $cfg_type = uc "CFG_$setting->{type}";
        my $optional = $setting->{optional} // "0";
        my $default = $setting->{default};
        my $mandatory = (not ($optional or $default)) ? 1 : 0;
        if ($setting->{type} eq 'string') {
            $default = defined $default ? "\"$default\"" : "NULL";
        } else {
            $default = $default // 0;
        }
        $default = ".default_val.def_$setting->{type} = $default";
        my $sizeof = scalar_type $setting->{type};
        my $offset_present = $setting->{optional} ? "offsetof(struct ${name}_item, ${sname}_is_present)" : 0;
        my $c = "";
        my $sub_group = "NULL";
        my $offset_len = 0;
        my $array_type = -1;

        my $arg_cl = "& ${name}_${sname}";

        if ($setting->{type} =~ /list|group/) {
            $c = make_table($hname, $setting);
            $sub_group = "table_${hname}";
            $sizeof = "struct ${hname}_item";
            $default = ".default_val.def_int = 0";
            $arg_cl = "NULL";
        }
        if ($setting->{type} =~ /list/) {
            $offset_len = "offsetof(struct ${name}_item, ${sname}_len)";
        }

        if ($setting->{type} =~ /array/) {
            $offset_len = "offsetof(struct ${name}_item, ${sname}_len)";
            $sizeof = scalar_type $setting->{element_type};
            $default = $setting->{default} // 0;
            $default = ".default_val.def_int = $default";
            $array_type = uc "CFG_$setting->{element_type}";
        }

        $out = <<EOF;
        $c $out
        { 
            /* name */          "$sname", 
            /* type */          $cfg_type, 
            /* sub_group*/      $sub_group,
            /* arg_cl */        $arg_cl,
            /* base_addr */     NULL,
            /* offset */        offsetof(struct ${name}_item, $sname),
            /* offset_len */    $offset_len,
            /* offset_present */ $offset_present,
            /* size */          sizeof($sizeof), 
            /* array_type */    $array_type,
            /* mandatory */     $mandatory, 
            /* optional */      $optional, 
            /* default_val*/    $default 
        },
EOF

    }
    $out .= "\t{ 0 }\n};\n";

    return $out;
}

# Return an entry index inside a group based on name
sub search_name_index {
    my ($item, $name) = @_;

    my $i = 0;
    until ($item->[$i]->{name} eq $name) {
        print "$i: $item->[$i]->{name} vs $name\n";
        $i++;
        if (not defined $item->[$i]) { 
            warn "$name not found\n" ; 
            return ;
        }
    }
    print "$i: $item->[$i]->{name} vs $name\n";
    return $i;
}

# Creates a pointer to the C struct that hosts schema element $s
# $name: basename of the config
# $root: root of the schema
# $s: element to find
# returns e.g. " & table_eg[5] ": $s is the 5th element in that table
sub make_baseref {
    my ($name, $root, $s) = @_;
    my $typename = cfgname2c $s->{list};
    my $base_entry = "table_${name}_${typename}";
    $base_entry =~ s/_[a-zA-Z0-9]+?$//;
    print "search base\n";
    my $be = $base_entry;
    $be =~ s/_/./g;
    $be =~ s/^\w+?\.//;
    $be =~ s/^\w+?\.//;
    $be = "" if $be eq $root->{config}->{name};
    my $it = get_item($root, $be);
    my $leaf_name = $s->{list};
    $leaf_name =~ s/^.*\.//;
    $base_entry .=  "[".  search_name_index($it->{items}, $leaf_name). "]";
    return "& $base_entry";
}

################################################################################
# Generate table for compound option processing
sub make_compound_table {
    my ($name, $root) = @_;

    my $out = <<EOF;
static struct compound_cl_arg compound_cl_args[] = {
EOF

    foreach my $s (@{$root->{cl_groups}}) {
        my $argname = $s->{name};

        my $typename = cfgname2c $s->{list};
        my $structname = $s->{list};
        $structname =~ s/\./->/g;

        my $list_targets = "${name}_$s->{name}_targets";
        my $entries = "static struct compound_cl_target $list_targets [] = {\n";
        my $item = get_item($root, $s->{list});

        foreach my $t (@{$s->{targets}}) {
            my $index = search_name_index($item->{items}, $t->{path});
            my $match = ($t->{value} =~ /\$(\d+)/) ? "$1": 0;
            my $value = $match ? 0 : "$t->{value}";
            my $type = $item->{items}[$index]->{type};
            $value = "\"$value\"" if $type eq 'string';
            $value = ".value.def_$type = $value";

            $entries .= "\t{ & table_${name}_${typename}[$index], $match, $value },\n";
        }
        $entries .= "\t{ 0 }\n};\n\n";

        $out = "$entries$out";

        my $targets = "$list_targets";
        my $arg_cl = "& ${name}_$s->{name}";
        my $regex = $s->{pattern};

        my $base_entry = make_baseref($name, $root, $s);

        # TODO: Override only works on groups, reject it otherwise
        my $override = 
            $s->{override} ? 
                "& table_${name}_$item->{name} [".
                    search_name_index($item->{items}, $s->{override})."]" : 
                "NULL";

        $out .= <<EOF;
        {   /* arg: $argname */
            .regex =           "$regex",
            .arg_cl =          $arg_cl,
            .base_entry =      $base_entry,
            .targets =         $targets,
            .override =        $override,
        },

EOF
    }
    $out .= "\tNULL\n};\n\n";

    return $out;
}

################################################################################
sub make_c_head {
    return <<EOF;
$banner
#define _GNU_SOURCE
#include <string.h>
#include <libconfig.h>
#include <stdlib.h>
#include <stddef.h>
#include "$header"
#include "argtable3.h"
#include <regex.h>

EOF
}

################################################################################
sub make_root_parser {
    my ($root) = @_;
    my $setting = $root->{config};
    my $name = cfgname2c $setting->{name};

    my $out = $snippets{header};
    my ($r_def, $r_init) = make_argtable_declarations($name, 1, $setting);
    my ($r_def2, $r_init2) = make_argtable_cl_groups_decls($name, @{$root->{cl_groups}});
    push @$r_def, @$r_def2;
    push @$r_init, @$r_init2;

    push @$r_def, "struct arg_end* ${name}_end;\n";
    push @$r_init, "\t${name}_end = arg_end(10)\n";

    # Add configuration file settings
    die "conffile_option not set\n" unless defined $root->{conffile_option};
    my ($short_opt, $long_opt) = @{$root->{conffile_option}};
    unshift @$r_def, "struct arg_file* ${name}_conffile;\n";
    unshift @$r_init, <<EOF;
        ${name}_conffile = arg_filen("$short_opt", "$long_opt", "<file>", 0, 1, "Specify configuration file"),
EOF

    
    $out .= <<EOF;
@$r_def
EOF

    $out .= make_table($name, $setting);

    $out .= make_compound_table($name, $root);

    $out .= $snippets{c_read_block};

    # Interpolate variables
    my %vars = (
        r_init => "@$r_init",
        name => "$name",
    );
    while (my ($vname, $vval) = each %vars) {
        $out =~ s/##$vname/$vval/g;
    }

    return $out;
}

################################################################################
# PRINTER GENERATION
################################################################################
sub make_print_settings {
    my ($name, $top_setting) = @_;
    my @settings = @{$top_setting->{items}};

    my $out = <<EOF;
static void ${name}_fprint(
        FILE* out,
        struct ${name}_item* $name,
        int depth) 
{
        int i;
EOF

    foreach my $setting (@settings) {
        my $sname = cfgname2c $setting->{name};
        if ($setting->{type} eq 'list') {
            my $hname = "${name}_${sname}";
            my $pname = "${hname}_fprint";
            my $c = make_print_settings($hname, $setting);
            $out = <<EOF
$c
$out
        indent(out, depth);
        fprintf(out, "${sname} [%d]:\\n", $name->${sname}_len);
        for (int i = 0; i < $name->${sname}_len; i++) {
            $pname(out, &$name->${sname}\[i\], depth+1);
        }
EOF
        } elsif ($setting->{type} eq 'group') {
            my $hname = "${name}_${sname}";
            my $pname = "${hname}_fprint";
            my $c = make_print_settings($hname, $setting);
            $out = <<EOF
$c
$out
        indent(out, depth);
        fprintf(out, "${sname}:\\n");
        $pname(out, $name->${sname}, depth+1);
EOF

        } elsif ($setting->{type} eq 'array') {
            my $fmt = scalar_type_print $setting->{element_type};
            $out .= <<EOF
        indent(out, depth);
        fprintf(out, "${sname} [%d]:\\n", $name->${sname}_len);
        for (i = 0; i < $name->${sname}_len; i++) {
            indent(out, depth+1);
            fprintf(out, "%d:\\t$fmt\\n", i, $name->${sname}\[i\]);
        }
EOF
        } elsif ($setting->{type} eq 'runtime') {
            # Don't print it, we know nothing about it
        } else {
            my $fmt = scalar_type_print $setting->{type};
            $out .= <<EOF;
        indent(out, depth);
        fprintf(out, "${sname}: $fmt", $name->${sname});
EOF
            if ($setting->{optional}) {
                $out .= <<EOF
        if (! $name->${sname}_is_present)
            fprintf(out, " <unset>");
EOF
            }
            $out .= <<EOF;
        fprintf(out, "\\n");
EOF
        }
    }

    $out .= "}\n";

    return $out;
}


################################################################################
sub make_root_print_settings {
    my ($root) = @_;
    my $setting = $root->{config};
    my $name = cfgname2c $setting->{name};

    my $out = <<EOF;

static void indent(FILE* out, int depth) 
{
    int i;
    for (i = 0; i < depth; i++)
        fprintf(out, "    ");
}

EOF

    $out .= make_print_settings($name, $setting);

    # Make the root printer a public symbol
    $out =~ s/static void ${name}_fprint/void ${name}_fprint/;
    return $out;
}

################################################################################

sub argtype {
    my ($in) = @_;
    my $out = {
        'bool' => 'arg_lit',
        'int' => 'arg_int',
        'int64' => 'arg_int',
        'float' => 'arg_dbl',
        'string' => 'arg_str',
    }->{$in};
    return $out;
}

# Type name inside the argtable structure
sub structtype {
    my ($in) = @_;
    my $out = {
        'bool' => 'count',
        'int' => 'ival',
        'int64' => 'ival',
        'float' => 'dval',
        'string' => 'sval',
    }->{$in};
    return $out;
}

################################################################################
sub make_argtable_declarations {
    my ($prefix, $max, $in) = @_;

    my (@def, @init);
    foreach my $setting (@{$in->{items}}) {
        next if $setting->{type} =~ /runtime/;

        $setting->{description} //= "";
        my $arg_type = argtype( $setting->{type} eq 'array'?  
            $setting->{element_type} : 
            $setting->{type});
        my $name = "${prefix}_" . cfgname2c $setting->{name};
        if ($setting->{type} =~ /group|list/) {
            next if exists $setting->{no_cl_accessors};
            my $sname = cfgname2c $setting->{name};
            my ($r_def, $r_init) = make_argtable_declarations("${prefix}_$sname", 10, $setting);
            push @def, @{$r_def};
            push @init, @{$r_init};
        } else {
            push @def, "struct $arg_type* $name;\n";
            my $arg_name = $name;
            $arg_name =~ s/.*?_//;  # Remove first prefix from cmdline name
            $arg_name =~ s/_/-/g;
            $max = 10 if $setting->{type} eq 'array';
            my $type = ", NULL";
            $type = "" if $arg_type eq 'arg_lit';
            $type = ", \"<n>\"" if $arg_type =~ /arg_int|arg_dbl/;
            $type = ", \"<str>\"" if $arg_type eq 'arg_str';
            $type = ", \"$setting->{argdesc}\"" if exists $setting->{argdesc};
            my $short = "NULL";
            $short = "\"$setting->{short}\"" if exists $setting->{short};
            push @init, <<EOF;
        $name = ${arg_type}n($short, "$arg_name"$type, 0, $max, "$setting->{description}"),
EOF
        }
    }
    return (\@def, \@init);
}

################################################################################
# Create declarations for group command line options
sub make_argtable_cl_groups_decls {
    my ($prefix, @groups) = @_;

    my (@def, @init);
    foreach my $g (@groups) {
        my $type = "NULL";
        $type = "\"$g->{argdesc}\"" if exists $g->{argdesc};
        my $short = "NULL";
        $short = "\"$g->{short}\"" if exists $g->{short};
        my $name = "${prefix}_$g->{name}";
        push @def, "\tstruct arg_str* $name;\n";
        push @init, "\t$name = arg_strn($short, \"$g->{name}\", $type, 0, 10, \"$g->{description}\"),\n";
    }
    return (\@def, \@init);
}

# Returns an item given a configuration object and a
# libconfig path, e.g. "application.window.size"
sub get_item {
    my ($root, $path) = @_;
    my $e = $root->{config};
    print "looking for item `$path'\n";
    my @p = split /\./, $path;
    foreach my $p (@p) {
        $e = (grep { $_->{name} eq $p } @{$e->{items}})[0];
    }
    return $e;
}

# Create code to copy group command line options to struct
sub make_arg_cl_groups_copy {
    my ($prefix, $root) = @_;

    my @groups = @{$root->{cl_groups}};

    my $out;
    foreach my $g (@groups) {
        # $g->{list} is a libconfig path to the list of
        # groups, e.g. "application.books". It is turned to
        # $typename, full name in C types("application_books")
        # and $structname, path ("application->books")
        my $typename = cfgname2c $g->{list};
        my $structname = $g->{list};
        $structname =~ s/\./->/g;
        my $st_name = "struct ${prefix}_${typename}_item";
        my $c_override = "/* No search for override */";
        if ($g->{override}) {
            my @override_setting = grep { $_->{path} eq $g->{override} } @{$g->{targets}};
            my $override_val = "\"$override_setting[0]->{value}\"";
            my $override_len;
            if ($override_val =~ /\$(\d+)/) {
                $override_val = "${prefix}_$g->{name}->sval [cl_i] + pmatch[$1].rm_so";
                $override_len = "pmatch[$1].rm_eo - pmatch[$1].rm_so";
            }
            $override_len //=  (length($override_val) - 2);  # val + 2 quotes
            $c_override = <<EOF
        for (i = 0; i < cfg->${structname}_len; i++) {
            if (!strncmp(cfg->${structname} [i].$g->{override}, $override_val,
                         $override_len)) {
                found = i;
                break;
            }
        }
EOF
        }
        my $target = get_item($root, $g->{list});
        if ($target->{type} eq 'list') {
            $c_override .= <<EOF;
        if (found == -1) {
            cfg->${structname }_len++;
            cfg->${structname } = realloc(cfg->${structname }, cfg->${structname }_len * sizeof(*cfg->${structname }));
            group = & cfg->${structname } [cfg->${structname }_len - 1];
        } else {
            group = & cfg->${structname } [found];
        }
EOF
        } elsif ($target->{type} eq 'group') {
            $c_override = "\tgroup = cfg->${structname};\n";
        } else {
            die "$g->{name}: Illegal target type `$target->{type}' (must be list or group)\n";
        }
        my $esc_pattern = $g->{pattern};
        $esc_pattern =~ s/\\/\\\\/g;

        $out .= <<EOF;
#define MAX_MATCH 10
    for (cl_i = 0; cl_i < ${prefix}_$g->{name}->count; cl_i++) {
        regex_t preg;
        regmatch_t pmatch[MAX_MATCH];
        int res = regcomp(&preg, "$esc_pattern", REG_EXTENDED);
        if (res) {
            int errlen = regerror(res, &preg, NULL, 0);
            char* errmsg = malloc(errlen);
            regerror(res, &preg, errmsg, errlen);

            fprintf(stderr, "$esc_pattern: %s\\n", errmsg);
            exit(1);
        }
        res = regexec(&preg, ${prefix}_$g->{name}->sval [cl_i], MAX_MATCH, &pmatch[0], 0);
        if (res) {
            fprintf(stderr, "--$g->{name} %s: Illegal argument\\n", ${prefix}_$g->{name}->sval [cl_i]);
            exit(1);
        }
        
        int param_len, i, found = -1;
        $st_name* group;

$c_override

        ${prefix}_${typename}_init(group);
EOF
        foreach my $t (@{$g->{targets}}) {
            my $v = $t->{value};
            my ($i, $l);
            if ($v =~ /\$(\d+)/) {
                $i = $1;
                $v = "${prefix}_$g->{name}->sval [cl_i]+pmatch[$i].rm_so";
                $l = "pmatch[$i].rm_eo - pmatch[$i].rm_so";
            } else {
                $l = length $v;
                $v = "\"$v\"";
            }
            my $item = get_item($root, "$g->{list}.$t->{path}");
            die "$t->{path}: unknown option\n" if not defined $item->{type};
            if ($item->{type} eq 'string') {
            $out .= <<EOF
        param_len = $l;
        group->$t->{path} = calloc(1, param_len + 1);
        memcpy(group->$t->{path}, $v, param_len);
EOF

            } elsif ($item->{type} =~ /int|int64|float/) {
                my $fmt = {
                    "int" => "%d",
                    "int64" => "%ld",
                    "float" => "%lf",
                }->{$item->{type}};
                $out .= <<EOF;
        sscanf($v, "$fmt", &group->$t->{path});
EOF
            } elsif ($item->{type} =~ /bool/) {
                $out .= "\tgroup->$t->{path} = *((char*)$v) - '0';\n";
            } else {
                die "$t->{path}: type `$item->{type}' not supported in compound options\n";
            }
        }
        $out .= "    }\n";
    }
    return $out;
}

################################################################################
sub make_argtable_copy2struct {
    my ($prefix, $in) = @_;

    # arg_index is the index in the command line argument
    # array, for groups and lists. ints also have indexes
    # anyway, so we use it all the time
    my $out = <<EOF;
static void ${prefix}_cl_c2s(int arg_index, struct ${prefix}_item* cfg) {
    int i, len;

EOF
    foreach my $setting (@{$in->{items}}) {
        next if $setting->{type} =~ /runtime/;
        next if $setting->{no_cl_accessors};

        my $name = cfgname2c $setting->{name};
        my $pname = "${prefix}_$name";

        if ($setting->{type} =~ /list/) {
            my $ac2s = make_argtable_copy2struct("${prefix}_${name}", $setting);
            $out = <<EOF;
$ac2s

$out
        len = ${pname}_$setting->{items}->[0]->{name}->count;
        if (len) {
            if (cfg->${name}_len) free(cfg->${name}); /* override conffile? */
            cfg->${name}_len = len;
            cfg->${name} = malloc(len * sizeof(*cfg->${name}));
            memset(cfg->$name, 0, len* sizeof(*cfg->$name));
            for (i = 0; i < len; i++) {
                ${prefix}_${name}_cl_c2s(i, &cfg->$name [i]);
            }
        }
EOF
        } elsif ($setting->{type} =~ /group/) {
            my $ac2s = make_argtable_copy2struct("${prefix}_${name}", $setting);
            $out = <<EOF;
$ac2s

$out
        if (!cfg->${name}) {
            cfg->${name} = malloc(sizeof(*cfg->${name}));
            memset(cfg->$name, 0, sizeof(*cfg->$name));
        }
        ${prefix}_${name}_cl_c2s(0, cfg->$name );
EOF
        } elsif ($setting->{type} =~ /array/) {
            my $type = structtype $setting->{element_type};
            my $assign = $type eq 'sval' ?
                    "asprintf(&cfg->$name [i], \"%s\", $pname->$type [i]);"
                    : "cfg->$name [i] = $pname->$type [i];";
            $out .= <<EOF;
            /* array */
            len = $pname->count;
            if (len) {
                if (cfg->${name}_len) free(cfg->${name}); /* override conffile? */
                cfg->${name}_len = len;
                cfg->$name = malloc(len * sizeof(*cfg->$name));
                for (i = 0; i < len; i++) {
                    $assign
                }
            }
EOF
        } else {
            $out .= "\tif ($pname->count) {\n";
            $out .= "\t\tcfg->${name}_is_present = 1;\n" if $setting->{optional};
            if ($setting->{type} =~ /int|int64/) {
                $out .= "\t\tcfg->$name = $pname->ival [arg_index];\n";
            } elsif ($setting->{type} eq 'float') {
                $out .= "\t\tcfg->$name = $pname->dval [arg_index];\n";
            } elsif ($setting->{type} eq 'bool') {
                $out .= "\t\tcfg->$name = $pname->count;\n";
            } elsif ($setting->{type} eq 'string') {
                $out .= "\t\tasprintf(& cfg->$name, \"%s\", $pname->sval [arg_index]);\n";
            } else {
                die "Unknown type $setting->{type}\n";
            }
            $out .= "\t}\n";
        }
    }
    $out .= "}\n\n";
    return $out;
}


################################################################################
sub make_argtable {
    my ($root) = @_;

    my $setting = $root->{config};
    my $prefix = $setting->{name};

    my $cl_groups_copy = make_arg_cl_groups_copy($prefix, $root);

    my $copy = make_argtable_copy2struct($prefix, $setting);

    return $copy;
}


################################################################################
# main
################################################################################


open my $h, "> $header" or die "$header: $!\n";
print $h make_root_header($hr);

open my $c, "> $parser" or die "$parser: $!\n";
print $c make_c_head;
print $c make_init($hr->{config}->{name}, $hr->{config});
print $c make_root_parser($hr);
print $c make_root_print_settings($hr);
print $c make_argtable($hr);


