#! /usr/bin/perl -w

# conf2struct: generate libconf parsers that read to structs
# Copyright (C) 2018  Yves Rutschle
# 
# This program is free software; you can redistribute it
# and/or modify it under the terms of the GNU General Public
# License as published by the Free Software Foundation; either
# version 2 of the License, or (at your option) any later
# version.
# 
# This program is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied
# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
# PURPOSE.  See the GNU General Public License for more
# details.
# 
# The full text for the General Public License is here:
# http://www.gnu.org/licenses/gpl.html

use strict;

use Conf::Libconfig;
use Getopt::Long;

use Data::Dumper;

my $date = scalar localtime;
my $banner = <<EOF;
/* Generated by conf2struct (https://www.rutschle.net/tech/conf2struct)
 * on $date. */

EOF


my $conf = Conf::Libconfig->new;
my $filename = shift @ARGV;
die "Usage:\n\tconf2struct <file.cfg>\n" unless defined $filename;
$conf->read_file($filename) or die "$filename: $!\n";
my $hr = $conf->fetch_hashref("/");

my $header = $hr->{header};
my $parser = $hr->{parser};


################################################################################
# Turns a libconfig type to a C type
sub scalar_type {
    my ($in) = @_;
    my $out = {
        'boolean' => 'int',
        'int' => 'int',
        'int64' => 'long long',
        'float' => 'double',
        'string' => 'const char*',
    }->{$in};
    die "Unknown setting $in\n" unless defined $out;
    return $out;
}

################################################################################
# Turns a libconfig type to the corresponding libconfig function to parse it
sub scalar_type_lookup {
    my ($in) = @_;
    {
        'boolean'       => 'config_setting_lookup_bool',
        'int'           => 'config_setting_lookup_int',
        'int64'         => 'config_setting_lookup_int64',
        'float'         => 'config_setting_lookup_float',
        'string'        => 'config_setting_lookup_string',
    }->{$in};
}

################################################################################
sub scalar_type_get {
    my ($in) = @_;
    {
        'boolean'       => 'config_setting_get_bool',
        'int'           => 'config_setting_get_int',
        'int64'         => 'config_setting_get_int64',
        'float'         => 'config_setting_get_float',
        'string'        => 'config_setting_get_string',
    }->{$in};
}

################################################################################
# Returns the printf format to print the libconfig type
sub scalar_type_print {
    my ($in) = @_;
    {
        'boolean' => '%d',
        'int' => '%d',
        'int64' => "%d",
        'float' => "%f",
        'string' => '%s',
    }->{$in};
}

################################################################################
# Turn libconfig setting names to C struct names
sub cfgname2c {
    s/-/_/g;
}

################################################################################
# HEADER GENERATION
################################################################################
# Taking a 'setting' (hash with name and @items), returns a
# couple ($structs, $decls) with $structs a string of
# structs needed inside this setting, and $decls the scalar
# definitions for the setting
sub make_decl_list {
    my ($prefix, $setting) = @_;

    my $name = $setting->{name};
    my ($structs, $decls) = ("", "");
    foreach my $setting (@{$setting->{items}}) {
        if ($setting->{type} eq 'list') {
            my $sname = "${prefix}_$setting->{name}_item";
            $structs .= make_struct_header("${prefix}_$setting->{name}", $setting);
            $decls = "$decls\tsize_t\t$setting->{name}_len;\n\tstruct $sname* $setting->{name};\n";
        } elsif ($setting->{type} eq 'array') {
            my $type = scalar_type($setting->{element_type});
            $decls= "$decls\tsize_t\t$setting->{name}_len;\n\t$type* $setting->{name};\n";
        } elsif ($setting->{type} eq 'runtime') {
            $decls .= "\t$setting->{c_type}\t$setting->{name};\n";
        } else {
            my $c_type = scalar_type $setting->{type};
            if ($setting->{optional} and $setting->{type} eq 'string') {
                $decls.= "\tint\t$setting->{name}_is_present;\n";
            }
            if ($setting->{var} and $setting->{type} eq 'string') {
                $c_type = "char*";
            }
            $decls.= "\t$c_type\t$setting->{name};\n";
        }
    }
    return ($structs, $decls);
}

################################################################################
sub make_struct_header {
    my ($prefix, $setting) = @_;

    my ($s, $l) = make_decl_list($prefix, $setting);
    my $out = "$s\nstruct ${prefix}_item {\n$l";
    if (exists $setting->{runtime_type}) {
        $out .= "\t$setting->{runtime_type}\tdata;\n";
    }
    $out .= "};\n";
    return $out;
}

################################################################################
sub make_root_header {
    my ($root) = @_;
    my $setting = $root->{config};
    my $name = $setting->{name};
    my $NAME = uc $name;
    my $out = <<EOF;
$banner 
#ifndef C2S_${NAME}_H
#define C2S_${NAME}_H
#include <libconfig.h>

EOF

foreach my $h (@{$root->{includes}}) {
    $h = "\"$h\"" unless $h =~ /\<.*\>/;
    $out .= "#include $h\n";
}

    $out .= make_struct_header($name, $setting);

    $out .= <<EOF;

int ${name}_parse_file(
        const char* filename,
        struct ${name}_item* $name, 
        const char** errmsg);

void ${name}_print(
    struct ${name}_item *${name},
    int depth);

#endif
EOF

    return $out;
}


################################################################################
# PARSER GENERATION
################################################################################
sub make_parser {
    my ($name, $top_setting) = @_;
    my @settings = @{$top_setting->{items}};

    my $out = <<EOF;
static int ${name}_parser(
        config_setting_t* cfg, 
        struct ${name}_item* $name, 
        const char** errmsg) 
{
        config_setting_t* setting;
        char* tmp;
        *errmsg = NULL;

EOF

    foreach my $setting (@settings) {
        if ($setting->{type} eq 'list') {
            my $hname = "${name}_$setting->{name}";
            my $dname = "${hname}_item";
            my $pname = "${hname}_parser";
            my $c = make_parser($hname, $setting);
            $out = <<EOF;
$c
$out
        $name->$setting->{name} = NULL;
        $name->$setting->{name}_len = 0;
        if ((setting = config_setting_lookup(cfg, \"$setting->{name}\"))) {
            int len = config_setting_length(setting);
            $name->$setting->{name} = malloc(len * sizeof(*$name->$setting->{name}));
            $name->$setting->{name}_len = len;
            for (int i = 0; i < len; i++) {
                config_setting_t* s = config_setting_get_elem(setting, i);
                int res = $pname(s, &$name->$setting->{name}\[i\], errmsg);
                if (!res) return 0;
            }
        }
EOF
        } elsif ($setting->{type} eq 'array') {
            my $getname = scalar_type_get $setting->{element_type};
            $out .= <<EOF
        $name->$setting->{name} = NULL;
        $name->$setting->{name}_len = 0;
        if ((setting = config_setting_lookup(cfg, "$setting->{name}"))) {
            int len = config_setting_length(setting);
            $name->$setting->{name} = malloc(len * sizeof(*$name->$setting->{name}));
            $name->$setting->{name}_len = len;
            for (int i = 0; i < len; i++) {
                config_setting_t* s = config_setting_get_elem(setting, i);
                $name->$setting->{name}\[i\] = $getname(s);
            }
        }
EOF
        } elsif ($setting->{type} eq 'runtime') {
            # Leave it alone
        } else {

            my $c_parse = scalar_type_lookup $setting->{type};
            if (exists $setting->{default} or exists $setting->{optional}) {
                if ($setting->{type} eq "string") {
                    if ($setting->{optional}) {
                        $setting->{default} = "NULL";
                    } else {
                        $setting->{default} = "\"$setting->{default}\"";
                    }
                }
                my $set_present = "";
                if ($setting->{optional}) {
                    $set_present = "else {\n\t\t$name->$setting->{name}_is_present = 1;\n\t}\n";
                }
                $out .= <<EOF;
        $name->$setting->{name} = $setting->{default};
        if (config_setting_lookup(cfg, \"$setting->{name}\")) {
            if ($c_parse(cfg, \"$setting->{name}\", &$name->$setting->{name}) == CONFIG_FALSE) {
                *errmsg = "Parsing of option \\\"$setting->{name}\\\" failed";
                return 0;
            } $set_present;
        }
EOF
            } else {
                $out .= <<EOF;
        if (config_setting_lookup(cfg, \"$setting->{name}\")) {
            if ($c_parse(cfg, \"$setting->{name}\", &$name->$setting->{name}) == CONFIG_FALSE) {
                *errmsg = "Parsing of option \\\"$setting->{name}\\\" failed";
                return 0;
            }
        } else {
            *errmsg = "Mandatory option \\\"$setting->{name}\\\" is missing";
            return 0;
        }
EOF
            }
            if ($setting->{type} eq 'string' and
                $setting->{var}) {
                $out .= <<EOF;
        if (asprintf(&tmp, "%s", $name->$setting->{name}) == -1) {
            *errmsg = "asprintf: cannot allocate memory";
            return 0;
        }
        $name->$setting->{name} = tmp;
EOF
            }
        }
    }
    $out .= "\treturn 1;\n}\n";

    return $out;
}

################################################################################
sub make_root_parser {
    my ($root) = @_;
    my $setting = $root->{config};
    my $name = $setting->{name};

my $out = <<EOF;
$banner

#define _GNU_SOURCE
#include <string.h>
#include <libconfig.h>
#include <stdlib.h>
#include "$header"

EOF
    $out .= make_parser($name, $setting);


    # Add file reader (which is the only public parsing API)
    $out .= <<EOF;

/* Public parser API: returns 0 on failure, 1 on success */
int ${name}_parse_file(const char* filename, struct ${name}_item* cfg, const char**errmsg)
{
    config_t c;

    config_init(&c);
    if (config_read_file(&c, filename) == CONFIG_FALSE) {
        if (config_error_line(&c) != 0) {
           asprintf(errmsg, "%s:%d:%s", 
                    filename,
                    config_error_line(&c),
                    config_error_text(&c));
           return 0;
        }
        asprintf(errmsg, "%s:%s", filename, config_error_text(&c));
        return 0;
    }
    return ${name}_parser(config_lookup(&c, "/"), cfg, errmsg);
}
EOF

    return $out;
}

################################################################################
# PRINTER GENERATION
################################################################################
sub make_print_settings {
    my ($name, $top_setting) = @_;
    my @settings = @{$top_setting->{items}};

    my $out = <<EOF;
static void ${name}_print(
        struct ${name}_item* $name,
        int depth) 
{
        int i;
EOF

    foreach my $setting (@settings) {
        if ($setting->{type} eq 'list') {
            my $hname = "${name}_$setting->{name}";
            my $dname = "${hname}_item";
            my $pname = "${hname}_print";
            my $c = make_print_settings($hname, $setting);
            $out = <<EOF
$c
$out
        indent(depth);
        printf("$setting->{name} [%d]:\\n", $name->$setting->{name}_len);
        for (int i = 0; i < $name->$setting->{name}_len; i++) {
            $pname(&$name->$setting->{name}\[i\], depth+1);
        }
EOF
        } elsif ($setting->{type} eq 'array') {
            my $fmt = scalar_type_print $setting->{element_type};
            $out .= <<EOF
        indent(depth);
        printf("$setting->{name} [%d]:\\n", $name->$setting->{name}_len);
        for (i = 0; i < $name->$setting->{name}_len; i++) {
            indent(depth+1);
            printf("%d:\\t$fmt\\n", i, $name->$setting->{name}\[i\]);
        }
EOF
        } elsif ($setting->{type} eq 'runtime') {
            # Don't print it, we know nothing about it
        } else {
            my $fmt = scalar_type_print $setting->{type};
            $out .= <<EOF
        indent(depth);
        printf("$setting->{name}: $fmt\\n", $name->$setting->{name});
EOF
        }
    }

    $out .= "   printf(\"\\n\");\n}\n";

    return $out;
}


################################################################################
sub make_root_print_settings {
    my ($root) = @_;
    my $setting = $root->{config};
    my $name = $setting->{name};

    my $out = <<EOF;

static void indent(int depth) 
{
    int i;
    for (i = 0; i < depth; i++)
        printf("    ");
}

EOF

    $out .= make_print_settings($name, $setting);

    # Make the root printer a public symbol
    $out =~ s/static void ${name}_print/void ${name}_print/;
    return $out;
}



################################################################################
################################################################################
# main
################################################################################


open my $h, "> $header" or die "$header: $!\n";
print $h make_root_header($hr);

open my $c, "> $parser" or die "$parser: $!\n";
print $c make_root_parser($hr);

# This is mostly for debugging
print $c make_root_print_settings($hr); #'config', @{$hr->{config}{items}});

