#! /usr/bin/perl -w

# conf2struct: generate libconf parsers that read to structs
# Copyright (C) 2018  Yves Rutschle
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice,
#    this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

use strict;

use Conf::Libconfig;
use Getopt::Long;

use Data::Dumper;

my $date = scalar localtime;
my $banner = <<EOF;
/* Generated by conf2struct (https://www.rutschle.net/tech/conf2struct/README)
 * on $date. */

EOF


my $conf = Conf::Libconfig->new;
my $filename = shift @ARGV;
die "Usage:\n\tconf2struct <file.cfg>\n" unless defined $filename;
$conf->read_file($filename) or die "$filename: $!\n";
my $hr = $conf->fetch_hashref("/");

my $header = $hr->{header};
my $parser = $hr->{parser};


################################################################################
# Turns a libconfig type to a C type
sub scalar_type {
    my ($in) = @_;
    my $out = {
        'boolean' => 'int',
        'int' => 'int',
        'int64' => 'long long',
        'float' => 'double',
        'string' => 'const char*',
    }->{$in};
    die "Unknown setting $in\n" unless defined $out;
    return $out;
}

################################################################################
# Turns a libconfig type to the corresponding libconfig function to parse it
sub scalar_type_lookup {
    my ($in) = @_;
    {
        'boolean'       => 'config_setting_lookup_bool',
        'int'           => 'config_setting_lookup_int',
        'int64'         => 'config_setting_lookup_int64',
        'float'         => 'config_setting_lookup_float',
        'string'        => 'config_setting_lookup_string',
    }->{$in};
}

################################################################################
sub scalar_type_get {
    my ($in) = @_;
    {
        'boolean'       => 'config_setting_get_bool',
        'int'           => 'config_setting_get_int',
        'int64'         => 'config_setting_get_int64',
        'float'         => 'config_setting_get_float',
        'string'        => 'config_setting_get_string',
    }->{$in};
}

################################################################################
# Returns the printf format to print the libconfig type
sub scalar_type_print {
    my ($in) = @_;
    {
        'boolean' => '%d',
        'int' => '%d',
        'int64' => "%ld",
        'float' => "%f",
        'string' => '%s',
    }->{$in};
}

################################################################################
# Turn libconfig setting names to C struct names
sub cfgname2c {
    my ($name) = @_;
    $name =~ s/-/_/g;
    return $name;
}

################################################################################
# HEADER GENERATION
################################################################################
# Taking a 'setting' (hash with name and @items), returns a
# couple ($structs, $decls) with $structs a string of
# structs needed inside this setting, and $decls the scalar
# definitions for the setting
sub make_decl_list {
    my ($prefix, $setting) = @_;

    my ($structs, $decls) = ("", "");
    foreach my $setting (@{$setting->{items}}) {
        my $name = cfgname2c $setting->{name};
        if ($setting->{type} eq 'list') {
            my $sname = "${prefix}_${name}_item";
            $structs .= make_struct_header("${prefix}_${name}", $setting);
            $decls = "$decls\tsize_t\t${name}_len;\n\tstruct $sname* ${name};\n";
        } elsif ($setting->{type} eq 'group') {
            my $sname = "${prefix}_${name}_item";
            $structs .= make_struct_header("${prefix}_${name}", $setting);
            $decls = "$decls\tstruct $sname* ${name};\n";
        } elsif ($setting->{type} eq 'array') {
            my $type = scalar_type($setting->{element_type});
            $decls= "$decls\tsize_t\t${name}_len;\n\t$type* ${name};\n";
        } elsif ($setting->{type} eq 'runtime') {
            $decls .= "\t$setting->{c_type}\t${name};\n";
        } else {
            my $c_type = scalar_type $setting->{type};
            if ($setting->{optional} and $setting->{type} eq 'string') {
                $decls.= "\tint\t${name}_is_present;\n";
            }
            if ($setting->{var} and $setting->{type} eq 'string') {
                $c_type = "char*";
            }
            $decls.= "\t$c_type\t${name};\n";
        }
    }
    return ($structs, $decls);
}

################################################################################
sub make_struct_header {
    my ($prefix, $setting) = @_;

    my ($s, $l) = make_decl_list($prefix, $setting);
    my $out = "$s\nstruct ${prefix}_item {\n$l";
    if (exists $setting->{runtime_type}) {
        $out .= "\t$setting->{runtime_type}\tdata;\n";
    }
    $out .= "};\n";
    return $out;
}

################################################################################
sub make_root_header {
    my ($root) = @_;
    my $setting = $root->{config};
    my $name = cfgname2c $setting->{name};
    my $NAME = uc $name;
    my $out = <<EOF;
$banner 
#ifndef C2S_${NAME}_H
#define C2S_${NAME}_H
#include <libconfig.h>

EOF

foreach my $h (@{$root->{includes}}) {
    $h = "\"$h\"" unless $h =~ /\<.*\>/;
    $out .= "#include $h\n";
}

    $out .= make_struct_header($name, $setting);

    $out .= <<EOF;

int ${name}_parse_file(
        const char* filename,
        struct ${name}_item* $name, 
        const char** errmsg);

void ${name}_print(
    struct ${name}_item *${name},
    int depth);

int ${name}_cl_parse(
    int argc,
    char* argv[],
    struct ${name}_item *${name});

#endif
EOF

    return $out;
}


################################################################################
# PARSER GENERATION
################################################################################
sub make_parser {
    my ($name, $top_setting) = @_;
    my @settings = @{$top_setting->{items}};

    my $out = <<EOF;
static int ${name}_parser(
        config_setting_t* cfg, 
        struct ${name}_item* $name, 
        const char** errmsg) 
{
        config_setting_t* setting;
        char* tmp;
        *errmsg = NULL;

EOF

    foreach my $setting (@settings) {
        my $sname = cfgname2c $setting->{name};
        if ($setting->{type} eq 'list') {
            my $hname = "${name}_${sname}";
            my $pname = "${hname}_parser";
            my $c = make_parser($hname, $setting);
            $out = <<EOF;
$c
$out
        $name->${sname} = NULL;
        $name->${sname}_len = 0;
        if ((setting = config_setting_lookup(cfg, \"${sname}\"))) {
            int len = config_setting_length(setting);
            $name->${sname} = malloc(len * sizeof(*$name->${sname}));
            $name->${sname}_len = len;
            for (int i = 0; i < len; i++) {
                config_setting_t* s = config_setting_get_elem(setting, i);
                int res = $pname(s, &$name->${sname}\[i\], errmsg);
                if (!res) return 0;
            }
        }
EOF
        } elsif ($setting->{type} eq 'array') {
            my $getname = scalar_type_get $setting->{element_type};
            $out .= <<EOF
        $name->${sname} = NULL;
        $name->${sname}_len = 0;
        if ((setting = config_setting_lookup(cfg, "${sname}"))) {
            int len = config_setting_length(setting);
            $name->${sname} = malloc(len * sizeof(*$name->${sname}));
            $name->${sname}_len = len;
            for (int i = 0; i < len; i++) {
                config_setting_t* s = config_setting_get_elem(setting, i);
                $name->${sname}\[i\] = $getname(s);
            }
        }
EOF
        } elsif ($setting->{type} eq 'group') {
            my $hname = "${name}_${sname}";
            my $pname = "${hname}_parser";
            my $c = make_parser($hname, $setting);
            $out = <<EOF
$c
$out
        $name->${sname} = NULL;
        if ((setting = config_setting_lookup(cfg, \"${sname}\"))) {
            $name->${sname} = malloc(sizeof(*$name->${sname}));
            int res = $pname(setting, $name->${sname}, errmsg);
            if (!res) return 0;
        }
                    
EOF

        } elsif ($setting->{type} eq 'runtime') {
            # Leave it alone
        } else {

            my $c_parse = scalar_type_lookup $setting->{type};
            if (exists $setting->{default} or exists $setting->{optional}) {
                if ($setting->{type} eq "string") {
                    if ($setting->{optional}) {
                        $setting->{default} = "NULL";
                    } else {
                        $setting->{default} = "\"$setting->{default}\"";
                    }
                }
                my $set_present = "";
                if ($setting->{optional}) {
                    $set_present = "else {\n\t\t$name->${sname}_is_present = 1;\n\t}\n";
                }
                $out .= <<EOF;
        $name->${sname} = $setting->{default};
        if (config_setting_lookup(cfg, \"${sname}\")) {
            if ($c_parse(cfg, \"${sname}\", &$name->${sname}) == CONFIG_FALSE) {
                *errmsg = "Parsing of option \\\"${sname}\\\" failed";
                return 0;
            } $set_present;
        }
EOF
            } else {
                $out .= <<EOF;
        if (config_setting_lookup(cfg, \"${sname}\")) {
            if ($c_parse(cfg, \"${sname}\", &$name->${sname}) == CONFIG_FALSE) {
                *errmsg = "Parsing of option \\\"${sname}\\\" failed";
                return 0;
            }
        } else {
            *errmsg = "Mandatory option \\\"$name.${sname}\\\" is missing";
            return 0;
        }
EOF
            }
            if ($setting->{type} eq 'string' and
                $setting->{var}) {
                $out .= <<EOF;
        if (asprintf(&tmp, "%s", $name->${sname}) == -1) {
            *errmsg = "asprintf: cannot allocate memory";
            return 0;
        }
        $name->${sname} = tmp;
EOF
            }
        }
    }
    $out .= "\treturn 1;\n}\n";

    return $out;
}

################################################################################
sub make_root_parser {
    my ($root) = @_;
    my $setting = $root->{config};
    my $name = cfgname2c $setting->{name};

my $out = <<EOF;
$banner

#define _GNU_SOURCE
#include <string.h>
#include <libconfig.h>
#include <stdlib.h>
#include "$header"

EOF
    $out .= make_parser($name, $setting);


    # Add file reader (which is the only public parsing API)
    $out .= <<EOF;

/* Public parser API: returns 0 on failure, 1 on success */
int ${name}_parse_file(const char* filename, struct ${name}_item* cfg, const char**errmsg)
{
    config_t c;

    config_init(&c);
    if (config_read_file(&c, filename) == CONFIG_FALSE) {
        if (config_error_line(&c) != 0) {
           asprintf(errmsg, "%s:%d:%s", 
                    filename,
                    config_error_line(&c),
                    config_error_text(&c));
           return 0;
        }
        asprintf(errmsg, "%s:%s", filename, config_error_text(&c));
        return 0;
    }
    return ${name}_parser(config_lookup(&c, "/"), cfg, errmsg);
}
EOF

    return $out;
}

################################################################################
# PRINTER GENERATION
################################################################################
sub make_print_settings {
    my ($name, $top_setting) = @_;
    my @settings = @{$top_setting->{items}};

    my $out = <<EOF;
static void ${name}_print(
        struct ${name}_item* $name,
        int depth) 
{
        int i;
EOF

    foreach my $setting (@settings) {
        my $sname = cfgname2c $setting->{name};
        if ($setting->{type} eq 'list') {
            my $hname = "${name}_${sname}";
            my $pname = "${hname}_print";
            my $c = make_print_settings($hname, $setting);
            $out = <<EOF
$c
$out
        indent(depth);
        printf("${sname} [%d]:\\n", $name->${sname}_len);
        for (int i = 0; i < $name->${sname}_len; i++) {
            $pname(&$name->${sname}\[i\], depth+1);
        }
EOF
        } elsif ($setting->{type} eq 'group') {
            my $hname = "${name}_${sname}";
            my $pname = "${hname}_print";
            my $c = make_print_settings($hname, $setting);
            $out = <<EOF
$c
$out
        indent(depth);
        printf("${sname}:\\n");
        $pname($name->${sname}, depth+1);
EOF

        } elsif ($setting->{type} eq 'array') {
            my $fmt = scalar_type_print $setting->{element_type};
            $out .= <<EOF
        indent(depth);
        printf("${sname} [%d]:\\n", $name->${sname}_len);
        for (i = 0; i < $name->${sname}_len; i++) {
            indent(depth+1);
            printf("%d:\\t$fmt\\n", i, $name->${sname}\[i\]);
        }
EOF
        } elsif ($setting->{type} eq 'runtime') {
            # Don't print it, we know nothing about it
        } else {
            my $fmt = scalar_type_print $setting->{type};
            $out .= <<EOF
        indent(depth);
        printf("${sname}: $fmt\\n", $name->${sname});
EOF
        }
    }

    $out .= "}\n";

    return $out;
}


################################################################################
sub make_root_print_settings {
    my ($root) = @_;
    my $setting = $root->{config};
    my $name = cfgname2c $setting->{name};

    my $out = <<EOF;

static void indent(int depth) 
{
    int i;
    for (i = 0; i < depth; i++)
        printf("    ");
}

EOF

    $out .= make_print_settings($name, $setting);

    # Make the root printer a public symbol
    $out =~ s/static void ${name}_print/void ${name}_print/;
    return $out;
}

################################################################################

sub argtype {
    my ($in) = @_;
    my $out = {
        'boolean' => 'arg_lit',
        'int' => 'arg_int',
        'int64' => 'arg_int',
        'float' => 'arg_dbl',
        'string' => 'arg_str',
    }->{$in};
    return $out;
}

# Type name inside the argtable structure
sub structtype {
    my ($in) = @_;
    my $out = {
        'boolean' => 'count',
        'int' => 'ival',
        'int64' => 'ival',
        'float' => 'dval',
        'string' => 'sval',
    }->{$in};
    return $out;
}

################################################################################
sub make_argtable_declarations {
    my ($prefix, $max, $in) = @_;

    my (@def, @init);
    foreach my $setting (@{$in->{items}}) {
        next if $setting->{type} =~ /runtime/;

        $setting->{description} //= "";
        my $arg_type = argtype( $setting->{type} eq 'array'?  
            $setting->{element_type} : 
            $setting->{type});
        my $name = "${prefix}_" . cfgname2c $setting->{name};
        if ($setting->{type} =~ /group|list/) {
            my $sname = cfgname2c $setting->{name};
            my ($r_def, $r_init) = make_argtable_declarations("${prefix}_$sname", 10, $setting);
            push @def, @{$r_def};
            push @init, @{$r_init};
        } else {
            push @def, "struct $arg_type* $name;\n";
            my $arg_name = $name;
            $arg_name =~ s/.*?_//;  # Remove first prefix from cmdline name
            $arg_name =~ s/_/-/g;
            $max = 10 if $setting->{type} eq 'array';
            my $type = "";
            $type = ", \"<n>\"" if $arg_type =~ /arg_int|arg_dbl/;
            $type = ", \"<str>\"" if $arg_type eq 'arg_str';
            push @init, <<EOF;
        $name = ${arg_type}n(NULL, "$arg_name"$type, 0, $max, "$setting->{description}"),
EOF
        }
    }
    return (\@def, \@init);
}
################################################################################
sub make_argtable_copy2struct {
    my ($prefix, $in) = @_;

    # arg_index is the index in the command line argument
    # array, for groups and lists. ints also have indexes
    # anyway, so we use it all the time
    my $out = <<EOF;
static void ${prefix}_cl_c2s(int arg_index, struct ${prefix}_item* cfg) {
    int i, len;

EOF
    foreach my $setting (@{$in->{items}}) {
        next if $setting->{type} =~ /runtime/;

        my $name = cfgname2c $setting->{name};
        my $pname = "${prefix}_$name";

        if ($setting->{type} =~ /list/) {
            my $ac2s = make_argtable_copy2struct("${prefix}_${name}", $setting);
            $out = <<EOF;
$ac2s

$out
        len = ${pname}_$setting->{items}->[0]->{name}->count;
        if (len) {
            if (cfg->${name}_len) free(cfg->${name}); /* override conffile? */
            cfg->${name}_len = len;
            cfg->${name} = malloc(len * sizeof(*cfg->${name}));
            memset(cfg->$name, 0, len* sizeof(*cfg->$name));
            for (i = 0; i < len; i++) {
                ${prefix}_${name}_cl_c2s(i, &cfg->$name [i]);
            }
        }
EOF
        } elsif ($setting->{type} =~ /group/) {
            my $ac2s = make_argtable_copy2struct("${prefix}_${name}", $setting);
            $out = <<EOF;
$ac2s

$out
        if (!cfg->${name}) {
            cfg->${name} = malloc(sizeof(*cfg->${name}));
            memset(cfg->$name, 0, sizeof(*cfg->$name));
        }
        ${prefix}_${name}_cl_c2s(0, cfg->$name );
EOF
        } elsif ($setting->{type} =~ /array/) {
            my $type = structtype $setting->{element_type};
            $out .= <<EOF;
            /* array */
            len = $pname->count;
            if (len) {
                if (cfg->${name}_len) free(cfg->${name}); /* override conffile? */
                cfg->${name}_len = len;
                cfg->$name = malloc(len * sizeof(*cfg->$name));
                for (i = 0; i < len; i++) {
                    cfg->$name [i] = $pname->$type [i];
                }
            }
EOF
        } else {
            $out .= "\tif ($pname->count) {\n";
            $out .= "\t\tcfg->${name}_is_present = 1;\n" if $setting->{optional};
            if ($setting->{type} =~ /int|int64/) {
                $out .= "\t\tcfg->$name = $pname->ival [arg_index];\n";
            } elsif ($setting->{type} eq 'float') {
                $out .= "\t\tcfg->$name = $pname->dval [arg_index];\n";
            } elsif ($setting->{type} eq 'boolean') {
                $out .= "\t\tcfg->$name = $pname->count;\n";
            } elsif ($setting->{type} eq 'string') {
                $out .= "\t\tcfg->$name = $pname->sval [arg_index];\n";
            } else {
                die "Unknown type $setting->{type}\n";
            }
            $out .= "\t}\n";
        }
    }
    $out .= "}\n\n";
    return $out;
}

################################################################################
sub make_argtable {
    my ($root) = @_;

    my $setting = $root->{config};
    my $prefix = $setting->{name};

    my ($r_def, $r_init) = make_argtable_declarations($prefix, 1, $setting);
    my $copy = make_argtable_copy2struct($prefix, $setting);

    # Add configuration file settings
    die "conffile_option not set\n" unless defined $root->{conffile_option};
    my ($short_opt, $long_opt) = @{$root->{conffile_option}};
    unshift @$r_def, "struct arg_file* ${prefix}_conffile;\n";
    unshift @$r_init, <<EOF;
        ${prefix}_conffile = arg_filen("$short_opt", "$long_opt", "<file>", 0, 1, ""),
EOF

    my $out = <<EOF;

#include "argtable3.h"

@$r_def
struct arg_end* ${prefix}_end;


$copy

int ${prefix}_cl_parse(int argc, char* argv[], struct ${prefix}_item* cfg) {
        void* argtable[] = {
@$r_init
        ${prefix}_end = arg_end(10)
    };
    const char* errmsg;
    int nerrors;

    nerrors = arg_parse(argc, argv, argtable);
    if (nerrors) {
        arg_print_errors(stdout, ${prefix}_end, "${prefix}"); 
        arg_print_syntax(stdout, argtable, "\\n");
        arg_print_glossary(stdout, argtable, "%s\t%s\\n");
        return 0;
    }

    if (${prefix}_conffile->count) {
        if (!${prefix}_parse_file(${prefix}_conffile->filename[0], cfg, &errmsg)) {
            fprintf(stderr, "%s\\n", errmsg);
            exit(1);
        }
    }

    ${prefix}_cl_c2s(0, cfg);
    return 1;
}
EOF


    return $out;
}


################################################################################
# main
################################################################################


open my $h, "> $header" or die "$header: $!\n";
print $h make_root_header($hr);

open my $c, "> $parser" or die "$parser: $!\n";
print $c make_root_parser($hr);

print $c make_root_print_settings($hr);

print $c make_argtable($hr);

